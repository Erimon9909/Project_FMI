#include <iostream>
#include<ctime>
#include<conio.h>
#include <cstdlib>
#include <windows.h>

using::std::cout;
using::std::endl;
using::std::cin;


const int MAX_JUMPS = 2;
const int UI_HEIGHT = 1;
const int MAPHEIGHT = 20;
const int MAPLENGHT = 95;
const int GRAVITY_DELAY = 300;

char map[MAPHEIGHT][MAPLENGHT];

unsigned long lastGravity = 0;
int jumpCount = 0;
int px = MAPHEIGHT - 2;
int py = MAPLENGHT / 2;


void StartScreen() {
    cout << "Welcome to the Game!" << endl;
    cout << "Type start to begin!" << endl;
    char input[10];
    cin >> input;
    if (strcmp(input, "start") == 0) {
        return;
    }
    else {
        system("cls");
        StartScreen();
    }
}

void GenerateUi() {
    int HP = 5;
    cout << "Player HP: ";
    for (int i = 0; i < HP; i++) {
        if (i == 4) {
            cout << "O";
        }
        else {
            cout << "O-";
        }
    }
    printf("       (a/d - Move, w - Jump, Double Jump, i/j/k/l - Attack) \n");

}

void DrawAt(int x, int y, char c) {
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), { (short)y, (short)(x + UI_HEIGHT) });
    cout << c;
}

bool Coinflip() {
    return (rand() % 3 == 0);
}
void GeneratePlatforms() {
    int minLength = 10;
    int maxLength = 15;
    int Length;

    int minHeight= 2;
    int maxHeight = 3;
    int PlatformGap = rand() % (maxHeight - minHeight + 1) + minHeight;

    int PlatformCount = 6;
    int PlatformStartX = MAPHEIGHT - PlatformGap;
    int PlatformStartY = PlatformStartX/2;

    for (int i = 0; i < PlatformCount; i++) {
        Length = rand() % (maxLength - minLength + 1) + minLength;
        
        for (int j = 0; j < Length; j++) {
            map[PlatformStartX][PlatformStartY] = '=';
            //DrawAt(PlatformStartX, PlatformStartY, '=');
            PlatformStartY++;
            if (map[PlatformStartX][PlatformStartY+1] == '#') {
                break;
            }
        }

        if (PlatformStartX < MAPHEIGHT / 2) {
            if (Coinflip()) {
                PlatformStartX -= PlatformGap;
            }
            else {
                PlatformStartX += PlatformGap;
            }
        }
        else {
            PlatformStartX -= PlatformGap;
        }

        PlatformStartY -= rand() % (Length/4 + 1);
    }

}


void GeneratePlayer() {
    char player = '@';
    map[px][py] = player;
}

void FillMap() {
    // Clear map
    for (int i = 0; i < MAPHEIGHT; i++) {
        for (int j = 0; j < MAPLENGHT; j++) {
            map[i][j] = ' ';
        }
    }

    // Borders
    for (int i = 0; i < MAPHEIGHT; i++) {
        map[i][0] = '#';
        map[i][MAPLENGHT - 1] = '#';
    }
    for (int j = 0; j < MAPLENGHT; j++) {
        map[0][j] = '#';
        map[MAPHEIGHT - 1][j] = '#';
    }

    // Generate reachable platforms
    GeneratePlatforms();

    // Place player
    map[px][py] = '@';
}

void GenerateMap() {
    for (int i = 0; i < MAPHEIGHT; i++) {
        for (int j = 0; j < MAPLENGHT; j++) {
            cout << map[i][j];
        }
        cout << endl;
    }
}

void Attack(char input) {
    switch (input) {
    case 'i':
        if (map[px - 1][py] == '#' || map[px - 1][py] == '=') {
            break;
        }
        DrawAt(px - 1, py - 1, '/');
        DrawAt(px - 1, py, '-');
        DrawAt(px - 1, py + 1, '\\');

        Sleep(500);
        DrawAt(px - 1, py - 1, ' ');
        DrawAt(px - 1, py, ' ');
        DrawAt(px - 1, py + 1, ' ');
        break;
    case 'k':
        if (map[px + 1][py] == '#' || map[px + 1][py] == '=') {
            break;
        }
        DrawAt(px + 1, py - 1, '\\');
        DrawAt(px + 1, py, '-');
        DrawAt(px + 1, py + 1, '/');

        Sleep(500);
        DrawAt(px + 1, py - 1, ' ');
        DrawAt(px + 1, py, ' ');
        DrawAt(px + 1, py + 1, ' ');
        break;
    case 'j':
        if (map[px + 1][py - 1] == '#' || map[px + 1][py - 1] == '=') {
            break;
        }
        DrawAt(px - 1, py - 1, '/');
        DrawAt(px, py - 1, '|');
        DrawAt(px + 1, py - 1, '\\');

        Sleep(500);
        DrawAt(px - 1, py - 1, ' ');
        DrawAt(px, py - 1, ' ');
        DrawAt(px + 1, py - 1, ' ');
        break;
    case 'l':
        if (map[px + 1][py + 1] == '#' || map[px + 1][py + 1] == '=') {
            break;
        }
        DrawAt(px - 1, py + 1, '\\');
        DrawAt(px, py + 1, '|');
        DrawAt(px + 1, py + 1, '/');

        Sleep(500);
        DrawAt(px - 1, py + 1, ' ');
        DrawAt(px, py + 1, ' ');
        DrawAt(px + 1, py + 1, ' ');
        break;
    }
}
void Movement(char input) {
    int NewX = px;
    int NewY = py;

    switch (input) {
    case 'a':
        NewY--;
        break;
    case 'd':
        NewY++;
        break;
    case 'w':
        if (jumpCount < MAX_JUMPS) {
            NewX -= 2;
            jumpCount++;
        }
        break;
    case 's':
        NewX++;
        break;
    case 'q':
        if (jumpCount < MAX_JUMPS) {
            NewX -= 2;
            NewY--;
            jumpCount++;
        }
        break;
    case 'e':
        if (jumpCount < MAX_JUMPS) {
            NewX -= 2;
            NewY++;
            jumpCount++;
        }
        break;
    }
    //Collision Detection
    if (map[NewX][NewY] == '#' || map[NewX][NewY] == '=') {
        return;
    }
    //Move Player

    map[px][py] = ' ';
    DrawAt(px, py, ' ');

    px = NewX;
    py = NewY;

    map[px][py] = '@';
    DrawAt(px, py, '@');
}
int main() {
    
    //StartScreen();
    srand(time(0));
    system("cls");
    GenerateUi();
    FillMap();
    GenerateMap();
    while (true) {
        char key = 0;
        if (_kbhit()) {
            key = _getch();
            Movement(key);
            Attack(key);
        }

        unsigned long now = clock();
        if (map[px + 1][py] == ' ' && now - lastGravity > GRAVITY_DELAY) {
            Movement('s');
            lastGravity = now;
        }
        else if (map[px + 1][py] != ' ') {
            jumpCount = 0;  // landed
        }

        Sleep(1000 / 60);
    }
    return 0;
}
